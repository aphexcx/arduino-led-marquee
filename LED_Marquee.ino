#define DEBUG true

#define uint8_t uint

#include <Arduino.h>

// Pin 13 has an LED connected on most Arduino boards.
// give it a name:
#define diagnosticLed 13

void diagnosticLedOn() {
    digitalWrite(diagnosticLed, HIGH);   // turn the LED on (HIGH is the voltage level)
}

void diagnosticLedOff() {
    digitalWrite(diagnosticLed, LOW);   // turn the LED on (HIGH is the voltage level)
}

volatile unsigned long timeOfLastBeat = 0;
const unsigned int FADE_MILLIS = 250; // number of ms beat flash takes to fade out

// http://www.gammon.com.au/interrupts
ISR (PCINT1_vect) {
    // handle pin change interrupt for A0 to A5 here
    if (PINC & bit (0)) {  // if it was high
        timeOfLastBeat = millis();
        diagnosticLedOn();
    } else {
        diagnosticLedOff();
    }
}

// Used to receive data on a virtual RX pin instead of the usual pin 0
#include <SoftwareSerial.h>

#define rxPin 10
#define txPin 11
SoftwareSerial virtualSerial(rxPin, txPin); // RX, TX

const char ASOT[] PROGMEM = "                    "
                            "I had a dream last night... A vision! I saw a world full of people. "
                            "Everybody was dancing! And screaming loud! They were just there to listen to "
                            "the music. Some even had their eyes closed. "
                            "Everybody was just smiling. "
                            "It was deep. "
                            "It was underground. "
                            "Tranceparent. "
                            "It was magical. "
                            "It was a happy place... "
                            "celebrating music! "
                            "Celebrating life! "
                            "Men and women - free - without a worry! "
                            "Then, when I woke up, I realized: "
                            "I WANNA BE IN THAT MOMENT! "
                            "The very essence of my existence is looking for that emotion! "
                            "And when the weekend comes...   "
                            "I  L I V E  F O R  T H A T  E N E R G Y . "; //598 chars

//How often to advertise "MSG ME!!!", e.g. every 5 marquee scrolls
#define ADVERTISE_EVERY 8
//Speed of invader sequence, lower is faster
#define INVADER_DELAY 60
//Speed of scrolling text marquee, lower is faster
#define MARQUEE_DELAY 25
//Affects how long the all your base style text stays on screen. Higher is faster
#define ALLYOURBASE_DELAY 12
//Speed of chars spelled out one by one effect, lower is faster
#define CHARS_ONEBYONE_DELAY 50

// The char indicating we should show a new message alert (currently BEL, \x07)
#define BEL '\x07'
// The char indicating we should show this string in the new message alert style (currently SOH, \x01)
#define SOH '\x01'
// The char indicating the end of extra data passed in after a control char
#define DLE 10

// chars indicating whether to enable/disable beat detector mic (connected to A0 pin change interrupt)
#define STX '\x02'
#define ETX '\x03'
// The char indicating we should show this string in flashing input style
#define EOT '\x04'
// The char indicating we should show this string in input style
#define ENQ '\x05'

// Pad this amount so that scrolling starts nicely off the end
#define STRING_PADDING 20

// The length of the buffer used to read a new string from the serial port
#define STRINGBUFFER_LEN 600 + STRING_PADDING + 1

//TODO strcpy or strcat to ensure padding on received string

// Leave room for a safety null terminator at the end.
//TODO change the harcoded padding to be generated by the length of STRING_PADDING
char bufferA[STRINGBUFFER_LEN + 1] = " ";

//                                     "The jaws that bite, the claws that catch! "
//                                     "Beware the Jubjub bird, and shun "
//                                     "The frumious Bandersnatch! ";
//TODO change the harcoded padding to be generated by the length of STRING_PADDING
char bufferB[STRINGBUFFER_LEN + 1] = "                     "; //note extra +1 char here (out of a abundance of caution)

char *currentBuffer = bufferA;

char *extraDataBuffer = strdup(currentBuffer + STRING_PADDING);

// The bool indicating we should show this string in the chooser style
bool showInChooserStyle = false;
// The bool indicating we should show this string in input style
int showInInputStyle = NULL;

// Change this to be at least as long as your pixel string (too long will work fine, just be a little slower)
#define NUM_PANELS 2  // Number of panels. There are 2.
#define PIXELS_PER_STRING 60  // Number of pixels in the string. I am using 60LED/M
#define PIXELS NUM_PANELS*PIXELS_PER_STRING  // Length of pixels total. I am using 2 meters of 60LED/M

// These values depend on which pins your 8 strings are connected to and what board you are using
// More info on how to find these at http://www.arduino.cc/en/Reference/PortManipulation

// PORTD controls Digital Pins 0-7 on the Uno

// You'll need to look up the port/bit combination for other boards.

// Note that you could also include the DigitalWriteFast header file to not need to to this lookup.

#define PIXEL_PORT  PORTD  // Port of the pin the pixels are connected to
#define PIXEL_DDR   DDRD   // Port of the pin the pixels are connected to


static const uint onBits = 0b11111110;   // Bit pattern to write to port to turn on all pins connected to LED strips.
// If you do not want to use all 8 pins, you can mask off the ones you don't want
// Note that these will still get 0 written to them when we send pixels
// TODO: If we have time, we could even add a variable that will and/or into the bits before writing to the port to support any combination of bits/values

// These are the timing constraints taken mostly from
// imperically measuring the output from the Adafruit library strandtest program

// Note that some of these defined values are for refernce only - the actual timing is determinted by the hard code.

#define T1H  814    // Width of a 1 bit in ns - 13 cycles
#define T1L  438    // Width of a 1 bit in ns -  7 cycles

#define T0H  312    // Width of a 0 bit in ns -  5 cycles
#define T0L  936    // Width of a 0 bit in ns - 15 cycles

// Phase #1 - Always 1  - 5 cycles
// Phase #2 - Data part - 8 cycles
// Phase #3 - Always 0  - 7 cycles

#define RES 50000   // Width of the low gap between bits to cause a frame to latch

// Here are some convience defines for using nanoseconds specs to generate actual CPU delays

#define NS_PER_SEC (1000000000L)          // Note that this has to be SIGNED since we want to be able to check for negative values of derivatives

#define CYCLES_PER_SEC (F_CPU)

#define NS_PER_CYCLE ( NS_PER_SEC / CYCLES_PER_SEC )

#define NS_TO_CYCLES(n) ( (n) / NS_PER_CYCLE )


// Sends a full 8 bits down all the pins, representing a single color of 1 pixel
// We walk though the 8 bits in colorbyte one at a time. If the bit is 1 then we send the 8 bits of row out. Otherwise we send 0.
// We send onBits at the first phase of the signal generation. We could just send 0xff, but that mught enable pull-ups on pins that we are not using.

/// Unforntunately we have to drop to ASM for this so we can interleave the computaions durring the delays, otherwise things get too slow.

// OnBits is the mask of which bits are connected to strips. We pass it on so that we
// do not turn on unused pins becuase this would enable the pullup. Also, hopefully passing this
// will cause the compiler to allocate a Register for it and avoid a reload every pass.
static inline void sendBitx8(const uint row, const uint colorbyte, const uint onBits) {

    asm volatile (


    "L_%=: \n\r"

    "out %[port], %[onBits] \n\t"                 // (1 cycles) - send either T0H or the first part of T1H. Onbits is a mask of which bits have strings attached.

    // Next determine if we are going to be sending 1s or 0s based on the current bit in the color....

    "mov r0, %[bitwalker] \n\t"                   // (1 cycles)
    "and r0, %[colorbyte] \n\t"                   // (1 cycles)  - is the current bit in the color byte set?
    "breq OFF_%= \n\t"                            // (1 cycles) - bit in color is 0, then send full zero row (takes 2 cycles if branch taken, count the extra 1 on the target line)

    // If we get here, then we want to send a 1 for every row that has an ON dot...
    "nop \n\t  "                                  // (1 cycles)
    "out %[port], %[row]   \n\t"                  // (1 cycles) - set the output bits to [row] This is phase for T0H-T1H.
    // ==========
    // (5 cycles) - T0H (Phase #1)


    "nop \n\t nop \n\t "                          // (2 cycles)
    "nop \n\t nop \n\t "                          // (2 cycles)
    "nop \n\t nop \n\t "                          // (2 cycles)
    "nop \n\t "                                   // (1 cycles)

    "out %[port], __zero_reg__ \n\t"              // (1 cycles) - set the output bits to 0x00 based on the bit in colorbyte. This is phase for T0H-T1H
    // ==========
    // (8 cycles) - Phase #2

    "ror %[bitwalker] \n\t"                      // (1 cycles) - get ready for next pass. On last pass, the bit will end up in C flag

    "brcs DONE_%= \n\t"                          // (1 cycles) Exit if carry bit is set as a result of us walking all 8 bits. We assume that the process around us will tak long enough to cover the phase 3 delay

    "nop \n\t \n\t "                             // (1 cycles) - When added to the 5 cycles in S:, we gte the 7 cycles of T1L

    "jmp L_%= \n\t"                              // (3 cycles)
    // (1 cycles) - The OUT on the next pass of the loop
    // ==========
    // (7 cycles) - T1L


    "OFF_%=: \n\r"                                // (1 cycles)    Note that we land here becuase of breq, which takes takes 2 cycles

    "out %[port], __zero_reg__ \n\t"              // (1 cycles) - set the output bits to 0x00 based on the bit in colorbyte. This is phase for T0H-T1H
    // ==========
    // (5 cycles) - T0H

    "ror %[bitwalker] \n\t"                      // (1 cycles) - get ready for next pass. On last pass, the bit will end up in C flag

    "brcs DONE_%= \n\t"                          // (1 cycles) Exit if carry bit is set as a result of us walking all 8 bits. We assume that the process around us will tak long enough to cover the phase 3 delay

    "nop \n\t nop \n\t "                          // (2 cycles)
    "nop \n\t nop \n\t "                          // (2 cycles)
    "nop \n\t nop \n\t "                          // (2 cycles)
    "nop \n\t nop \n\t "                          // (2 cycles)
    "nop \n\t "                                   // (1 cycles)

    "jmp L_%= \n\t"                               // (3 cycles)
    // (1 cycles) - The OUT on the next pass of the loop
    // ==========
    //(15 cycles) - T0L


    "DONE_%=: \n\t"

    // Don't need an explicit delay here since the overhead that follows will always be long enough

    ::
    [port]    "I"(_SFR_IO_ADDR(PIXEL_PORT)),
    [row]   "d"(row),
    [onBits]   "d"(onBits),
    [colorbyte]   "d"(colorbyte),     // Phase 2 of the signal where the actual data bits show up.
    [bitwalker] "r"(
            0x80)                      // Alocate a register to hold a bit that we will walk down though the color byte

    );

    // Note that the inter-bit gap can be as long as you want as long as it doesn't exceed the reset timeout (which is A long time)

}


// Just wait long enough without sending any bits to cause the pixels to latch and display the last sent frame
void show() {
    delayMicroseconds((RES / 1000UL) +
                      1);       // Round up since the delay must be _at_least_ this long (too short might not work, too long not a problem)
}


// Send 3 bytes of color data (R,G,B) for a signle pixel down all the connected stringsat the same time
// A 1 bit in "row" means send the color, a 0 bit means send black.
static inline void sendRowRGB(uint row, uint r, uint g, uint b) {

    sendBitx8(row, g, onBits);    // WS2812 takes colors in GRB order
    sendBitx8(row, r, onBits);    // WS2812 takes colors in GRB order
    sendBitx8(row, b, onBits);    // WS2812 takes colors in GRB order

}

// Turn off all pixels
static inline void clear() {

    cli();
    for (unsigned int i = 0; i < PIXELS; i++) {

        sendRowRGB(0, 0, 0, 0);
    }
    sei();

    show();
}

// This nice 5x7 font from here...
// http://sunge.awardspace.com/glcd-sd/node4.html

// Font details:
// 1) Each char is fixed 5x7 pixels.
// 2) Each byte is one column.
// 3) Columns are left to right order, leftmost byte is leftmost column of pixels.
// 4) Each column is 8 bits high.
// 5) Bit #7 is top line of char, Bit #1 is bottom.
// 6) Bit #0 is always 0, becuase this pin is used as serial input and setting to 1 would enable the pull-up.

// defines ascii characters 0x20-0x7F (32-127)
// PROGMEM after variable name as per https://www.arduino.cc/en/Reference/PROGMEM

#define FONT_WIDTH 5
#define INTERCHAR_SPACE 1
#define ASCII_OFFSET 0x20    // ASSCI code of 1st char in font array
// Max chars a single panel can display at once
#define MAX_CHARS_PER_PANEL PIXELS_PER_STRING / (FONT_WIDTH + INTERCHAR_SPACE)

const uint Font5x7[]
        PROGMEM = {
                0x00, 0x00, 0x00, 0x00, 0x00,//
                0x00, 0x00, 0xfa, 0x00, 0x00,// !
                0x00, 0xe0, 0x00, 0xe0, 0x00,// "
                0x28, 0xfe, 0x28, 0xfe, 0x28,// #
                0x24, 0x54, 0xfe, 0x54, 0x48,// $
                0xc4, 0xc8, 0x10, 0x26, 0x46,// %
                0x6c, 0x92, 0xaa, 0x44, 0x0a,// &
                0x00, 0xa0, 0xc0, 0x00, 0x00,// '
                0x00, 0x38, 0x44, 0x82, 0x00,// (
                0x00, 0x82, 0x44, 0x38, 0x00,// )
                0x10, 0x54, 0x38, 0x54, 0x10,// *
                0x10, 0x10, 0x7c, 0x10, 0x10,// +
                0x00, 0x0a, 0x0c, 0x00, 0x00,// ,
                0x10, 0x10, 0x10, 0x10, 0x10,// -
                0x00, 0x06, 0x06, 0x00, 0x00,// .
                0x04, 0x08, 0x10, 0x20, 0x40,// /
                0x7c, 0x8a, 0x92, 0xa2, 0x7c,// 0
                0x00, 0x42, 0xfe, 0x02, 0x00,// 1
                0x42, 0x86, 0x8a, 0x92, 0x62,// 2
                0x84, 0x82, 0xa2, 0xd2, 0x8c,// 3
                0x18, 0x28, 0x48, 0xfe, 0x08,// 4
                0xe4, 0xa2, 0xa2, 0xa2, 0x9c,// 5
                0x3c, 0x52, 0x92, 0x92, 0x0c,// 6
                0x80, 0x8e, 0x90, 0xa0, 0xc0,// 7
                0x6c, 0x92, 0x92, 0x92, 0x6c,// 8
                0x60, 0x92, 0x92, 0x94, 0x78,// 9
                0x00, 0x6c, 0x6c, 0x00, 0x00,// :
                0x00, 0x6a, 0x6c, 0x00, 0x00,// ;
                0x00, 0x10, 0x28, 0x44, 0x82,// <
                0x28, 0x28, 0x28, 0x28, 0x28,// =
                0x82, 0x44, 0x28, 0x10, 0x00,// >
                0x40, 0x80, 0x8a, 0x90, 0x60,// ?
                0x4c, 0x92, 0x9e, 0x82, 0x7c,// @
                0x7e, 0x88, 0x88, 0x88, 0x7e,// A
                0xfe, 0x92, 0x92, 0x92, 0x6c,// B
                0x7c, 0x82, 0x82, 0x82, 0x44,// C
                0xfe, 0x82, 0x82, 0x44, 0x38,// D
                0xfe, 0x92, 0x92, 0x92, 0x82,// E
                0xfe, 0x90, 0x90, 0x80, 0x80,// F
                0x7c, 0x82, 0x82, 0x8a, 0x4c,// G
                0xfe, 0x10, 0x10, 0x10, 0xfe,// H
                0x00, 0x82, 0xfe, 0x82, 0x00,// I
                0x04, 0x02, 0x82, 0xfc, 0x80,// J
                0xfe, 0x10, 0x28, 0x44, 0x82,// K
                0xfe, 0x02, 0x02, 0x02, 0x02,// L
                0xfe, 0x40, 0x20, 0x40, 0xfe,// M
                0xfe, 0x20, 0x10, 0x08, 0xfe,// N
                0x7c, 0x82, 0x82, 0x82, 0x7c,// O
                0xfe, 0x90, 0x90, 0x90, 0x60,// P
                0x7c, 0x82, 0x8a, 0x84, 0x7a,// Q
                0xfe, 0x90, 0x98, 0x94, 0x62,// R
                0x62, 0x92, 0x92, 0x92, 0x8c,// S
                0x80, 0x80, 0xfe, 0x80, 0x80,// T
                0xfc, 0x02, 0x02, 0x02, 0xfc,// U
                0xf8, 0x04, 0x02, 0x04, 0xf8,// V
                0xfe, 0x04, 0x18, 0x04, 0xfe,// W
                0xc6, 0x28, 0x10, 0x28, 0xc6,// X
                0xc0, 0x20, 0x1e, 0x20, 0xc0,// Y
                0x86, 0x8a, 0x92, 0xa2, 0xc2,// Z
                0x00, 0x00, 0xfe, 0x82, 0x82,// [
                0x40, 0x20, 0x10, 0x08, 0x04,// (backslash)
                0x82, 0x82, 0xfe, 0x00, 0x00,// ]
                0x20, 0x40, 0x80, 0x40, 0x20,// ^
                0x02, 0x02, 0x02, 0x02, 0x02,// _
                0x00, 0x80, 0x40, 0x20, 0x00,// `
                0x04, 0x2a, 0x2a, 0x2a, 0x1e,// a
                0xfe, 0x12, 0x22, 0x22, 0x1c,// b
                0x1c, 0x22, 0x22, 0x22, 0x04,// c
                0x1c, 0x22, 0x22, 0x12, 0xfe,// d
                0x1c, 0x2a, 0x2a, 0x2a, 0x18,// e
                0x10, 0x7e, 0x90, 0x80, 0x40,// f
                0x10, 0x28, 0x2a, 0x2a, 0x3c,// g
                0xfe, 0x10, 0x20, 0x20, 0x1e,// h
                0x00, 0x22, 0xbe, 0x02, 0x00,// i
                0x04, 0x02, 0x22, 0xbc, 0x00,// j
                0x00, 0xfe, 0x08, 0x14, 0x22,// k
                0x00, 0x82, 0xfe, 0x02, 0x00,// l
                0x3e, 0x20, 0x18, 0x20, 0x1e,// m
                0x3e, 0x10, 0x20, 0x20, 0x1e,// n
                0x1c, 0x22, 0x22, 0x22, 0x1c,// o
                0x3e, 0x28, 0x28, 0x28, 0x10,// p
                0x10, 0x28, 0x28, 0x18, 0x3e,// q
                0x3e, 0x10, 0x20, 0x20, 0x10,// r
                0x12, 0x2a, 0x2a, 0x2a, 0x04,// s
                0x20, 0xfc, 0x22, 0x02, 0x04,// t
                0x3c, 0x02, 0x02, 0x04, 0x3e,// u
                0x38, 0x04, 0x02, 0x04, 0x38,// v
                0x3c, 0x02, 0x0c, 0x02, 0x3c,// w
                0x22, 0x14, 0x08, 0x14, 0x22,// x
                0x30, 0x0a, 0x0a, 0x0a, 0x3c,// y
                0x22, 0x26, 0x2a, 0x32, 0x22,// z
                0x00, 0x10, 0x6c, 0x82, 0x00,// {
                0x00, 0x00, 0xfe, 0x00, 0x00,// |
                0x00, 0x82, 0x6c, 0x10, 0x00,// }
                0x10, 0x10, 0x54, 0x38, 0x10,// ~
                0x10, 0x38, 0x54, 0x10, 0x10,// 
        };

// Send the pixels to form the specified char, not including interchar space
// skip is the number of pixels to skip at the begining to enable sub-char smooth scrolling

// TODO: Subtract the offset from the char before starting the send sequence to save time if necessary
// TODO: Also could pad the beginning of the font table to aovid the offset subtraction at the cost of 20*8 bytes of progmem
// TODO: Could pad all chars out to 8 bytes wide to turn the the multiply by FONT_WIDTH into a shift

static inline void sendChar(uint c, uint skip, uint r, uint g, uint b) {

    const uint *charbase = Font5x7 + ((c - ' ') * FONT_WIDTH);
    uint col = FONT_WIDTH;

    while (skip--) {
        charbase++;
        col--;
    }

    while (col--) {
        sendRowRGB(pgm_read_byte_near(charbase++), r, g, b);
    }

    // TODO: FLexible interchar spacing

    sendRowRGB(0, r, g, b);    // Interchar space

}


// Show the passed string. The last letter of the string will be in the rightmost pixels of the display.
// Skip is how many cols of the 1st char to skip for smooth scrolling
static inline void sendString(const char *s, uint skip, const uint r, const uint g, const uint b) {

    unsigned int l = PIXELS / (FONT_WIDTH + INTERCHAR_SPACE);

    sendChar(*s, skip, r, g, b);   // First char is special case becuase it can be stepped for smooth scrolling

    while (*(++s) && l--) {

        sendChar(*s, 0, r, g, b);

    }
}

// A nice arcade font from...
// http://jared.geek.nz/2014/jan/custom-fonts-for-microcontrollers

#define ALTFONT_WIDTH 8

const uint altfont[]
        PROGMEM = {
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,//
                0x06, 0x06, 0x30, 0x30, 0x60, 0xc0, 0xc0, 0x00,// !
                0xe0, 0xe0, 0x00, 0xe0, 0xe0, 0x00, 0x00, 0x00,// "
                0x28, 0xfe, 0xfe, 0x28, 0xfe, 0xfe, 0x28, 0x00,// #
                0xf6, 0xf6, 0xd6, 0xd6, 0xd6, 0xde, 0xde, 0x00,// $
                0xc6, 0xce, 0x1c, 0x38, 0x70, 0xe6, 0xc6, 0x00,// %
                0xfe, 0xfe, 0xd6, 0xc6, 0x16, 0x1e, 0x1e, 0x00,// &
                0xe0, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,// '
                0xfe, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,// (
                0x00, 0xfe, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x00,// )
                0x6c, 0x10, 0xfe, 0xfe, 0xfe, 0x10, 0x6c, 0x00,// *
                0x10, 0x10, 0x7c, 0x10, 0x10, 0x00, 0x00, 0x00,// +
                0x06, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,// ,
                0x10, 0x10, 0x10, 0x10, 0x10, 0x00, 0x00, 0x00,// -
                0x06, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,// .
                0x0e, 0x38, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00,// /
                0xfe, 0xfe, 0xc6, 0xc6, 0xc6, 0xfe, 0xfe, 0x00,// 0
                0x06, 0x66, 0x66, 0xfe, 0xfe, 0x06, 0x06, 0x00,// 1
                0xde, 0xde, 0xd6, 0xd6, 0xd6, 0xf6, 0xf6, 0x00,// 2
                0xc6, 0xc6, 0xd6, 0xd6, 0xd6, 0xfe, 0xfe, 0x00,// 3
                0xf8, 0xf8, 0x18, 0x18, 0x18, 0x7e, 0x7e, 0x00,// 4
                0xf6, 0xf6, 0xd6, 0xd6, 0xd6, 0xde, 0xde, 0x00,// 5
                0xfe, 0xfe, 0x36, 0x36, 0x36, 0x3e, 0x3e, 0x00,// 6
                0xc2, 0xc6, 0xce, 0xdc, 0xf8, 0xf0, 0xe0, 0x00,// 7
                0xfe, 0xfe, 0xd6, 0xd6, 0xd6, 0xfe, 0xfe, 0x00,// 8
                0xf8, 0xf8, 0xd8, 0xd8, 0xd8, 0xfe, 0xfe, 0x00,// 9
                0x36, 0x36, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,// :
                0x36, 0x36, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,// ;
                0x10, 0x28, 0x44, 0x44, 0x00, 0x00, 0x00, 0x00,// <
                0x28, 0x28, 0x28, 0x28, 0x28, 0x00, 0x00, 0x00,// =
                0x44, 0x44, 0x28, 0x10, 0x00, 0x00, 0x00, 0x00,// >
                0xc0, 0xc0, 0xda, 0xda, 0xd0, 0xf0, 0xf0, 0x00,// ?
                0xfe, 0xfe, 0xc6, 0xf6, 0xd6, 0xf6, 0xf6, 0x00,// @
                0xfe, 0xfe, 0xd8, 0xd8, 0xd8, 0xfe, 0xfe, 0x00,// A
                0xfe, 0xfe, 0xd6, 0xd6, 0xf6, 0x7e, 0x3e, 0x00,// B
                0xfe, 0xfe, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0x00,// C
                0xfe, 0xfe, 0xc6, 0xc6, 0xe6, 0x7e, 0x3e, 0x00,// D
                0xfe, 0xfe, 0xd6, 0xd6, 0xd6, 0xd6, 0xd6, 0x00,// E
                0xfe, 0xfe, 0xd0, 0xd0, 0xd0, 0xc0, 0xc0, 0x00,// F
                0xfe, 0xfe, 0xc6, 0xc6, 0xd6, 0xde, 0xde, 0x00,// G
                0xfe, 0xfe, 0x18, 0x18, 0x18, 0xfe, 0xfe, 0x00,// H
                0xc6, 0xc6, 0xfe, 0xfe, 0xc6, 0xc6, 0xc6, 0x00,// I
                0x06, 0x06, 0x06, 0x06, 0x06, 0xfe, 0xfc, 0x00,// J
                0xfe, 0xfe, 0x18, 0x18, 0x78, 0xfe, 0x9e, 0x00,// K
                0xfe, 0xfe, 0x06, 0x06, 0x06, 0x06, 0x06, 0x00,// L
                0xfe, 0xfe, 0xc0, 0x60, 0xc0, 0xfe, 0xfe, 0x00,// M
                0xfe, 0xfe, 0x70, 0x38, 0x1c, 0xfe, 0xfe, 0x00,// N
                0xfe, 0xfe, 0xc6, 0xc6, 0xc6, 0xfe, 0xfe, 0x00,// O
                0xfe, 0xfe, 0xd8, 0xd8, 0xd8, 0xf8, 0xf8, 0x00,// P
                0xfe, 0xfe, 0xc6, 0xce, 0xce, 0xfe, 0xfe, 0x00,// Q
                0xfe, 0xfe, 0xd8, 0xdc, 0xde, 0xfe, 0xfa, 0x00,// R
                0xf6, 0xf6, 0xd6, 0xd6, 0xd6, 0xde, 0xde, 0x00,// S
                0xc0, 0xc0, 0xfe, 0xfe, 0xc0, 0xc0, 0xc0, 0x00,// T
                0xfe, 0xfe, 0x06, 0x06, 0x06, 0xfe, 0xfe, 0x00,// U
                0xf8, 0xfc, 0x0e, 0x06, 0x0e, 0xfc, 0xf8, 0x00,// V
                0xfc, 0xfe, 0x06, 0x0c, 0x06, 0xfe, 0xfc, 0x00,// W
                0xee, 0xfe, 0x38, 0x10, 0x38, 0xfe, 0xee, 0x00,// X
                0xe0, 0xf0, 0x3e, 0x1e, 0x3e, 0xf0, 0xe0, 0x00,// Y
                0xce, 0xde, 0xd6, 0xd6, 0xd6, 0xf6, 0xe6, 0x00,// Z
                0xfe, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,// [
                0xe0, 0x38, 0x0e, 0x00, 0x00, 0x00, 0x00, 0x00,// \
  0x00,0xfe,0xfe,0x00,0x00,0x00,0x00,0x00,// ]
                0x00, 0xfe, 0x02, 0xfe, 0x00, 0x00, 0x00, 0x00,// ^
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,// _
                0x00, 0xfe, 0x02, 0xfe, 0x00, 0x00, 0x00, 0x00,// `
                0xfe, 0xfe, 0xd8, 0xd8, 0xd8, 0xfe, 0xfe, 0x00,// a
                0xfe, 0xfe, 0xd6, 0xd6, 0xf6, 0x7e, 0x3e, 0x00,// b
                0xfe, 0xfe, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0x00,// c
                0xfe, 0xfe, 0xc6, 0xc6, 0xe6, 0x7e, 0x3e, 0x00,// d
                0xfe, 0xfe, 0xd6, 0xd6, 0xd6, 0xd6, 0xd6, 0x00,// e
                0xfe, 0xfe, 0xd0, 0xd0, 0xd0, 0xc0, 0xc0, 0x00,// f
                0xfe, 0xfe, 0xc6, 0xc6, 0xd6, 0xde, 0xde, 0x00,// g
                0xfe, 0xfe, 0x18, 0x18, 0x18, 0xfe, 0xfe, 0x00,// h
                0xc6, 0xc6, 0xfe, 0xfe, 0xc6, 0xc6, 0xc6, 0x00,// i
                0x06, 0x06, 0x06, 0x06, 0x06, 0xfe, 0xfc, 0x00,// j
                0xfe, 0xfe, 0x18, 0x18, 0x78, 0xfe, 0x9e, 0x00,// k
                0xfe, 0xfe, 0x06, 0x06, 0x06, 0x06, 0x06, 0x00,// l
                0xfe, 0xfe, 0xc0, 0x60, 0xc0, 0xfe, 0xfe, 0x00,// m
                0xfe, 0xfe, 0x70, 0x38, 0x1c, 0xfe, 0xfe, 0x00,// n
                0xfe, 0xfe, 0xc6, 0xc6, 0xc6, 0xfe, 0xfe, 0x00,// o
                0xfe, 0xfe, 0xd8, 0xd8, 0xd8, 0xf8, 0xf8, 0x00,// p
                0xfe, 0xfe, 0xc6, 0xce, 0xce, 0xfe, 0xfe, 0x00,// q
                0xfe, 0xfe, 0xd8, 0xdc, 0xde, 0xfe, 0xfa, 0x00,// r
                0xf6, 0xf6, 0xd6, 0xd6, 0xd6, 0xde, 0xde, 0x00,// s
                0xc0, 0xc0, 0xfe, 0xfe, 0xc0, 0xc0, 0xc0, 0x00,// t
                0xfe, 0xfe, 0x06, 0x06, 0x06, 0xfe, 0xfe, 0x00,// u
                0xf8, 0xfc, 0x0e, 0x06, 0x0e, 0xfc, 0xf8, 0x00,// v
                0xfc, 0xfe, 0x06, 0x0c, 0x06, 0xfe, 0xfc, 0x00,// w
                0xee, 0xfe, 0x38, 0x10, 0x38, 0xfe, 0xee, 0x00,// x
                0xe0, 0xf0, 0x3e, 0x1e, 0x3e, 0xf0, 0xe0, 0x00,// y
                0xce, 0xde, 0xd6, 0xd6, 0xd6, 0xf6, 0xe6, 0x00,// z
                0x38, 0xfe, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x00,// {
                0xfe, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,// |
                0x00, 0xfe, 0xfe, 0x38, 0x00, 0x00, 0x00, 0x00,// }
                0x00, 0xfe, 0x02, 0xfe, 0x00, 0x00, 0x00, 0x00,// ~
        };


// Keep track of where we are in the color cycle between chars
static uint altbright = 0;

int loopcount = 0;

void diagnosticBlink() {
    if (DEBUG) {
        diagnosticLedOn();
//        delay(500);
//        diagnosticLedOff();
//        delay(500);
//        diagnosticLedOn();
//        delay(500);
        diagnosticLedOff();
//        delay(300);
    }
}

// Send a char with a column-based color cycle
static inline void sendCharAlt(uint c) {

    const uint *charbase = altfont + ((c - ' ') * ALTFONT_WIDTH);

    uint col = ALTFONT_WIDTH;

    while (col--) {

        sendRowRGB(pgm_read_byte_near(charbase++), altbright, 0, 0x80);

        altbright += 10;
    }

    sendRowRGB(0, 0, 0, 0);
    altbright += 10;

}

// Show the passed string with the arcade font and a nice vertical color cycle effect

static inline void sendStringAlt(const char *s) {

    unsigned int l = PIXELS / (ALTFONT_WIDTH + INTERCHAR_SPACE);

    sendRowRGB(0, 0x00, 0x00, 0x00);
    sendRowRGB(0, 0x00, 0x00, 0x00);
    sendRowRGB(0, 0x00, 0x00, 0x00);


    while (l--) {

        char c;

        c = *s++;

        if (!c) break;

        sendCharAlt(c);

    }
}


void setupDiagnosticLed() {
    pinMode(diagnosticLed, OUTPUT);
}

// Set the specified pins up as digital out

void setupLeds() {

    PIXEL_DDR |= onBits;   // Set all used pins to output

}

void startSerial() {
    // set the data rate for the SoftwareSerial port
    virtualSerial.begin(19200);
    virtualSerial.flush();
//    Serial.begin(19200);
}

void stopSerial() {
    virtualSerial.end();
}

void setupSerial() {
    // define pin modes for tx, rx:
    pinMode(rxPin, INPUT);
    pinMode(txPin, OUTPUT);
}

// https://learn.adafruit.com/led-tricks-gamma-correction/the-quick-fix

const uint PROGMEM
        gamma[] = {
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1,
        1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2,
        2, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 5, 5, 5,
        5, 6, 6, 6, 6, 7, 7, 7, 7, 8, 8, 8, 9, 9, 9, 10,
        10, 10, 11, 11, 11, 12, 12, 13, 13, 13, 14, 14, 15, 15, 16, 16,
        17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22, 23, 24, 24, 25,
        25, 26, 27, 27, 28, 29, 29, 30, 31, 32, 32, 33, 34, 35, 35, 36,
        37, 38, 39, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 50,
        51, 52, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 66, 67, 68,
        69, 70, 72, 73, 74, 75, 77, 78, 79, 81, 82, 83, 85, 86, 87, 89,
        90, 92, 93, 95, 96, 98, 99, 101, 102, 104, 105, 107, 109, 110, 112, 114,
        115, 117, 119, 120, 122, 124, 126, 127, 129, 131, 133, 135, 137, 138, 140, 142,
        144, 146, 148, 150, 152, 154, 156, 158, 160, 162, 164, 167, 169, 171, 173, 175,
        177, 180, 182, 184, 186, 189, 191, 193, 196, 198, 200, 203, 205, 208, 210, 213,
        215, 218, 220, 223, 225, 228, 231, 233, 236, 239, 241, 244, 247, 249, 252, 255
};

// Map 0-255 visual brightness to 0-255 LED brightness
#define GAMMA(x) (pgm_read_byte(&gamma[x]))

// TODO idxToBlink that isn't always last char
void showAsInputStyle(char *str, int idxToBlink, int mode) {

    str = str + STRING_PADDING + 1; // drop initial padding

    int length = strlen(str);
    int shiftBy = constrain(length - MAX_CHARS_PER_PANEL, 0, length);
    // Shift string from the start if it is longer than the max chars we can show,
    // so that last MAX_CHARS_PER_PANEL chars are always visible (plus _)
    str = str + shiftBy;

    unsigned int count = 20;

    clear();

    idxToBlink = strlen(str) - 1;

//    cli();
//    // Send string, except for last char (which is '_')
//    for (uint i = 0; i < length; i++) {
//        int r = 0xff;
//        int g = 0xff;
//        int b = 0xff;
////        if (i == idxToBlink ) {
////            sendChar(str[idxToBlink], 0, r, brightness, brightness);
////        } else {
//            sendChar(str[i], 0, GAMMA(r), GAMMA(g), GAMMA(b));
////        }
//    }

    while (count > 0) {

        count--;

        uint brightness = ((count % 100) * 256) / 100;

        cli();
        // Send string, except for last char (which is '_')
        for (uint i = 0; i < length; i++) {
            int r = 0xff;
            int g = 0xff;
            int b = 0xff;
            // Blink idxToBlink char, or all chars if we're in input warning mode
            if (i == idxToBlink || mode == EOT) {
                sendChar(str[i], 0, 0xff, brightness, brightness);
            } else {
                sendChar(str[i], 0, GAMMA(r), GAMMA(g), GAMMA(b));
            }
        }

        sendRowRGB(0x00, 0, 0, 0xff);

        sei();
        show();
    }
}

void showAsChooser(char *blinkyStr, char *countyStr) {

//    int maxStrLen = 10; // max number of chars to show //TODO or, could scroll the whole thing
//    blinkyStr[maxStrLen] = 0x00; //chop here


    int blinkyLen = strlen(blinkyStr);
    int shiftBy = constrain(blinkyLen - MAX_CHARS_PER_PANEL - strlen(countyStr), 0, blinkyLen);
    // Shift string from the start if it is longer than the max chars we can show,
    // so that last MAX_CHARS_PER_PANEL chars are always visible (plus _)
//    blinkyStr = blinkyStr + shiftBy;

    unsigned int count = 58;

    clear();
    while (count > 0) {

        count--;

        uint brightness = GAMMA(((count % 100) * 256) / 100);

        cli();

        // County part
        sendString(countyStr, 0, 0x80, 0, 0);

        sendRowRGB(0x00, 0, 0, 0xff);

        // Blinky part
//        while (*blinkyStr) {
//        for (int s = 0; s <= shiftBy; s++) {
//            if (s == blinkyLen) {
//                break;
//            }
//            for (uint step = 0; step < FONT_WIDTH +
//                                       INTERCHAR_SPACE; step++) {
//                // step though each column of the 1st char for smooth scrolling
//                sendString(blinkyStr, step, brightness, brightness, brightness);
        sendString(blinkyStr, 0, brightness, brightness, brightness);
//            }
//            blinkyStr = blinkyStr + s;
//        }
        sei();
//        delay(MARQUEE_DELAY); // speed. higher = slower

        show();
    }
}

void showcountdown() {

    // Start sequence.....

    const char *countdownstr = "NEW MSG IN   ";

    unsigned int count = 600;

    clear();
    while (count > 0) {

        count--;

        uint digit1 = count / 100;
        uint digit2 = (count - (digit1 * 100)) / 10;
        uint digit3 = (count - (digit1 * 100) - (digit2 * 10));

        uint char1 = digit1 + '0';
        uint char2 = digit2 + '0';
        uint char3 = digit3 + '0';

        uint brightness = GAMMA(((count % 100) * 256) / 100);

        cli();
        sendString(countdownstr, 0, brightness, brightness, brightness);

        sendRowRGB(0x00, 0, 0, 0xff);

        //  sendChar( '0' , 0 , 0x80, 0 , 0 );

        sendChar(char1, 0, 0x80, 0, 0);
        sendChar('.', 0, 0x80, 0, 0);
        sendChar(char2, 0, 0x80, 0, 0);
        sendChar(char3, 0, 0x80, 0, 0);

        sei();
        show();
    }

    count = 100;

    // One last farewell blink

    while (count > 0) {

        count--;


        uint brightness = GAMMA(((count % 100) * 256) / 100);

        cli();
        sendString(countdownstr, 0, brightness, brightness, brightness);

        sendRowRGB(0x00, 0, 0, 0xff);   // We need to quickly send a blank byte just to keep from missing our deadlne.
        sendChar('0', 0, brightness, 0, 0);
        sendChar('.', 0, brightness, 0, 0);
        sendChar('0', 0, brightness, 0, 0);
        sendChar('0', 0, brightness, 0, 0);


        sei();
        show();
    }


}

void showstarfieldcustom(int stars) {

    const uint field = 40;       // Good size for a field, must be less than 256 so counters fit in a byte

    uint sectors = (PIXELS / field);      // Repeating sectors makes for more stars and faster update

    for (unsigned int i = 0; i < stars; i++) {

        unsigned int r = random(PIXELS * 8);   // Random slow, so grab one big number and we will break it down.

        unsigned int x = r / 8;
        uint y = r & 0x07;                // We use 7 rows
        uint bitmask = (2 << y);           // Start at bit #1 since we never use the bottom bit

        cli();

        unsigned int l = x;

        while (l--) {
            sendRowRGB(0, 0x00, 0x00, 0x00);
        }

        sendRowRGB(bitmask, 0x40, 0x40, 0xff);  // Starlight blue

        l = PIXELS - x;

        while (l--) {
            sendRowRGB(0, 0x00, 0x00, 0x00);
        }


        sei();

        // show(); // Not needed - random is alwasy slow enough to trigger a reset

    }

}

void showstarfield() {
    showstarfieldcustom(300);
}

static inline void sendIcon(const uint *fontbase, uint which, int8_t shift, uint width, uint r, uint g, uint b) {

    const uint *charbase = fontbase + (which * width);

    if (shift < 0) {

        uint shiftabs = -1 * shift;

        while (width--) {

            uint row = pgm_read_byte_near(charbase++);

            sendRowRGB(row << shiftabs, r, g, b);

        }

    } else {


        while (width--) {

            sendRowRGB((pgm_read_byte_near(charbase++) >> shift) & onBits, r, g, b);

        }

    }

}


void showCharsOneByOneAndWait(const char *pointsStr, uint r, uint g, uint b, int delayMs) {

    clear();

    for (uint p = 0; p < strlen(pointsStr); p++) {

        cli();
//        sendStringAlt("                ");
//        sendIcon(enemies, which, 0, ENEMIES_WIDTH, r, g, b);
        for (uint i = 0; i <= p; i++) {
            sendChar(*(pointsStr + i), 0, r >> 2, g >> 2, b >> 2);     // Dim text slightly
        }
        sei();
        delay(CHARS_ONEBYONE_DELAY);

    }
    delay(delayMs);
}

//TODO take char, pad (& center) to MAX_CHARS_PER_PANEL, and multiply by NUM_PANELS
void showCharsOneByOneOnBothPanels(const char *pointsStr, uint r, uint g, uint b) {
    showCharsOneByOneAndWait(pointsStr, r, g, b, 500);
}

void showCharsOneByOne(const char *pointsStr, uint r, uint g, uint b) {
    showCharsOneByOneAndWait(pointsStr, r, g, b, 500);
}

void showallyourbasestyle(char *str) {
//    const char *allyourbase = "CAT: ALL YOUR BASE ARE BELONG TO US !!!";

    clear();
    for (unsigned int slide = 4000; slide; slide -= 10) {
        altbright = (slide & 0xff);
        cli();
//        sendChar(' ', 0, 0, 0, 0);
        sendStringAlt(str);
        sei();
        show();
        delay(ALLYOURBASE_DELAY);
    }

}

void showInstagramAd() {
    showCharsOneByOne("INSTAGRAM:INSTAGRAM:", GAMMA(0xfe), GAMMA(0xd4), GAMMA(0x3b));
    showCharsOneByOneAndWait(" @APHEXCX  @APHEXCX ", GAMMA(0xef), GAMMA(0x0c), GAMMA(0x1d), 1000);

//    showallyourbasestyle("INSTAGRAM INSTAGRAM ");
//    showallyourbasestyle("@APHEXCX  @APHEXCX ");
}

void showTalkToUsAd() {

    showCharsOneByOne("THANK YOU THANK YOU ", GAMMA(0xfe), GAMMA(0xd4), GAMMA(0x3b));
    showCharsOneByOne("FOR RIDINGFOR RIDING", GAMMA(0xfe), GAMMA(0xd4), GAMMA(0x3b));
//    showCharsOneByOneAndWait("  BAAAHS    BAAAHS  ", GAMMA(0xea), GAMMA(0x17), GAMMA(0x8c), 1000);
    showallyourbasestyle("BAAAHS BAAAHS");

    showCharsOneByOne("WANT TO...WANT TO...", GAMMA(0x04), GAMMA(0xff), GAMMA(0x19));
    showCharsOneByOneAndWait("ADD A MSG?ADD A MSG?", GAMMA(0x04), GAMMA(0xff), GAMMA(0x19), 1200);
//    showCharsOneByOneAndWait("ASK US!!<3ASK US!!<3", GAMMA(0xff), GAMMA(0x05), GAMMA(0x5d), 1200);
    showCharsOneByOneAndWait("CUM ON IN!CUM ON IN!", GAMMA(0xff), GAMMA(0x05), GAMMA(0x5d), 1200);
}

void showMsgMeAd() {
    clear();
//    showInstagramAd();
    showTalkToUsAd();
//    showCharsOneByOne(" MSG ME!!! MSG ME!!! ", GAMMA(0xE6), GAMMA(0x00), GAMMA(0x7E));

//    showCharsOneByOne(1, " = 10 POINTS", 0x00, 0xff, 0x00);
}

#define ENEMIES_WIDTH 11

//TODO hmm, the last one is an explosion and I've never seen that displayed before
const uint enemies[]
        PROGMEM = {
                // anjuna v1: upside down anjuna
//              0x00, 0x0C, 0x1e, 0x3b, 0x19, 0x0b, 0x05, 0x09, 0x11, 0x22, 0x44, 0x48, 0x50, 0x60, 0x40, 0x00,
                // anjuna v2: inner downward triangle touches bar
//                0x08, 0x18, 0x3C, 0x6E, 0x4C, 0x68, 0x50, 0x48, 0x44, 0x22, 0x11, 0x09, 0x05, 0x03, 0x01,
                // anjuna v3: space between bar and downward triangle, necessitating a larger downward triangle
//                0x08, 0x1C, 0x3E, 0x6C, 0x48, 0x60, 0x50, 0x48, 0x44, 0x22, 0x11, 0x09, 0x05, 0x03, 0x01,
//                0x08, 0x1C, 0x3E, 0x6C, 0x48, 0x60, 0x50, 0x48, 0x44, 0x22, 0x11, 0x09, 0x05, 0x03, 0x01,
                // anjuna v3 with filled in bar
//                0x08, 0x1C, 0x3E, 0x6C, 0x48, 0x60, 0x70, 0x78, 0x7C, 0x3E, 0x1F, 0x0F, 0x07, 0x03, 0x01
                // baaahs v1: upside down
//                0x06, 0x0d, 0x1D, 0x33, 0x47, 0x42, 0x47, 0x33, 0x1D, 0x0d, 0x06,
                // baaahs v2:
                0x30, 0x58, 0x5C, 0x66, 0x71, 0x21, 0x71, 0x66, 0x5C, 0x58, 0x30,
                0x30, 0x58, 0x5C, 0x66, 0x71, 0x21, 0x71, 0x66, 0x5C, 0x58, 0x30

                //
//                0x70, 0xf4, 0xfe, 0xda, 0xd8, 0xf4, 0xf4, 0xd8, 0xda, 0xfe, 0xf4, 0x70, // Enemy 1 - open
//                0x72, 0xf2, 0xf4, 0xdc, 0xd8, 0xf4, 0xf4, 0xd8, 0xdc, 0xf4, 0xf2, 0x72, // Enemy 1 - close
//                0x1c, 0x30, 0x7c, 0xda, 0x7a, 0x78, 0x7a, 0xda, 0x7c, 0x30, 0x1c, 0x00, // Enemy 2 - open
//                0xf0, 0x3a, 0x7c, 0xd8, 0x78, 0x78, 0x78, 0xd8, 0x7c, 0x3a, 0xf0, 0x00, // Enemy 2 - closed
//                0x92, 0x54, 0x10, 0x82, 0x44, 0x00, 0x00, 0x44, 0x82, 0x10, 0x54, 0x92, // Explosion
        };

void showInvaders() {

    uint acount = PIXELS / (ENEMIES_WIDTH + FONT_WIDTH);      // How many aliens do we have room for?

    for (int8_t row = -7; row < 7; row++) {     // Walk down the rows

        //  Walk them 6 pixels per row

        // ALternate direction on each row

        uint start, end, step;

        if (row & 1) {
            start = 1;
            end = 8;
            step = 1;
        } else {
            start = 7;
            end = 0;
            step = -1;
        }

        for (char p = start; p != end; p += step) {
            // Now slowly move aliens
            // work our way though the aliens moving each one to the left

            cli();

            // Start with margin
            uint margin = p;

            while (margin--) {
                sendRowRGB(0, 0x00, 0x00, 0x00);
            }

            for (uint l = 0; l < acount; l++) {
                sendIcon(enemies, p & 1, row, ENEMIES_WIDTH, GAMMA(0x4f), GAMMA(0x62), GAMMA(0xd2));
//                sendChar(' ', 0, 0x00, 0x00, 0x00); // No over crowding
                sendRowRGB(0, 0x00, 0x00, 0x00);
                sendRowRGB(0, 0x00, 0x00, 0x00);
                sendRowRGB(0, 0x00, 0x00, 0x00);
                sendRowRGB(0, 0x00, 0x00, 0x00);
                sendRowRGB(0, 0x00, 0x00, 0x00);
            }

            sei();

            delay(INVADER_DELAY);
        }
    }
    // delay(200);
}


#define JAB_MAX_BRIGHTNESS 0xff //(255 (100%))
//#define JAB_MAX_BRIGHTNESS 0x7f //(127)
#define JAB_MIN_BRIGHTNESS 0x00
#define JAB_STEPS (JAB_MAX_BRIGHTNESS-JAB_MIN_BRIGHTNESS)


////lines below are for the microphone sampling from Adafruit autogain mic
//
//const int sampleWindow = MARQUEE_DELAY; // Sample window width in mS (50 mS = 20Hz)
//unsigned int sample;
//const double VOLTAGE = 5.0;
//
//double sampleSound() {
//    //first run the sound sampling
//    unsigned long startMillis = millis(); // Start of sample window
//    unsigned int peakToPeak = 0;   // peak-to-peak level
//
//    unsigned int signalMax = 0;
//    unsigned int signalMin = 1024;
//
//    // collect data for 50 mS
//    while (millis() - startMillis < sampleWindow) {
//        //open while loop
//        sample = analogRead(0);
//        if (sample < 1024)  // toss out spurious readings
//        {
//            //open 1st if loop in while
//            if (sample > signalMax) {
//                //open 2nd if
//                signalMax = sample;  // save just the max levels
//            }//close 2nd if
//            else if (sample < signalMin) {
//                //open 3rd if
//                signalMin = sample;  // save just the min levels
//            }//close 3rd if
//        }//close 1st if
//    }//close while loop
//    peakToPeak = signalMax - signalMin;  // max - min = peak-peak amplitude
//    double volts = (peakToPeak * VOLTAGE) / 1024;  // convert to volts
//    return volts;
//}

// Keep color step between marquee calls, but still bump the sector by 1 every call so each new message starts with a
// noticeably different color
uint sector = 1;
uint colorStep = 0;

void marquee() {

    const char *m = currentBuffer;

    // Text foreground color cycle effect
    sector++;
    if (sector == 3) {
        sector = 0;
    }

    float beatPct = 0.0f;
    unsigned long delta;

    while (*m) {

        if (colorStep == JAB_STEPS) {
            colorStep = 0;
            sector++;
            if (sector == 3) {
                sector = 0;
            }
        } else {
            colorStep++;
        }

        uint rampup = GAMMA(JAB_MIN_BRIGHTNESS + colorStep);
        uint rampdown = GAMMA(JAB_MIN_BRIGHTNESS + (JAB_STEPS - colorStep));

        uint r0, g0, b0, r, g, b;

        switch (sector) {
            case 0:
                r0 = rampup;
                g0 = rampdown;
                b0 = JAB_MIN_BRIGHTNESS;
                break;
            case 1:
                r0 = rampdown;
                g0 = JAB_MIN_BRIGHTNESS;
                b0 = rampup;
                break;
            case 2:
                r0 = JAB_MIN_BRIGHTNESS;
                g0 = rampup;
                b0 = rampdown;
                break;

        };

        for (uint step = 0; step < FONT_WIDTH +
                                   INTERCHAR_SPACE; step++) {   // step though each column of the 1st char for smooth scrolling

            delta = millis() - timeOfLastBeat;
            // beat proportion
            beatPct = constrain((float) delta / (float) FADE_MILLIS, 0.0f, 1.0f);

            if (beatPct >= 1.0f) {
                r = r0;
                g = g0;
                b = b0;
            } else if (beatPct > 0.0f) {
                // Fade between white and rgb depending on how long ago the beat was
                r = (uint)((1.0f - beatPct) * (float) JAB_MAX_BRIGHTNESS + beatPct * (float) r0);
                g = (uint)((1.0f - beatPct) * (float) JAB_MAX_BRIGHTNESS + beatPct * (float) g0);
                b = (uint)((1.0f - beatPct) * (float) JAB_MAX_BRIGHTNESS + beatPct * (float) b0);
            } else {
                // beatPct == 0.0, meaning it just happened.
                // Flash on beats
                // Full white to save doing the computation cycles
                r = JAB_MAX_BRIGHTNESS;
                g = JAB_MAX_BRIGHTNESS;
                b = JAB_MAX_BRIGHTNESS;
            }

            cli();

            sendString(m, step, r, g, b);

            sei();

//            Serial.begin(19200);
//            Serial.flush();
//
////            delay(MARQUEE_DELAY); // speed. higher = slower
//
//            double volts = sampleSound();
//            int sound = (volts * 10);
//
//            int soundLevel = map(sound, 1, 10, 0, 9);
//
//            //if loud sound:
//            if (soundLevel > 1) {
//                sector++;
//                if (sector == 3) {
//                    sector = 0;
//                }
//            }
//            if (beat) {
//                sector++;
//                if (sector == 3) {
//                    sector = 0;
//                }
//            }

            delay(MARQUEE_DELAY); // speed. higher = slower


            PORTB |= 0x01;
            delay(1);
            PORTB &= ~0x01;

        }

        m++;

    }

}


// Notifies the IMX that we're ready to retrieve custom message data
bool readSerialData() {
    startSerial();
//    delay(200);
    // send special symbol so IMX knows to respond with custom message data
    virtualSerial.print("~");

    char *incomingBuffer;
    if (currentBuffer == bufferA) {
        incomingBuffer = bufferB;
    } else {
        incomingBuffer = bufferA;
    }
    //Hmm do I need to do this each time or only if something valid was read?
//        memset(bufferA, 0x00, STRINGBUFFER_LEN);
    int len = virtualSerial.readBytesUntil('\r', incomingBuffer + STRING_PADDING, STRINGBUFFER_LEN - STRING_PADDING);

    incomingBuffer[STRING_PADDING + len] = 0x00; // Null terminate

    bool shouldShowNewMsgAlert = false;
    showInChooserStyle = false;
    showInInputStyle = false;
    // If we got something, swap currentBuffer to point to the incoming.
    if (len > 0) {
        currentBuffer = incomingBuffer;
        // If the first non-padding char is a BEL, show the new msg alert
        if (currentBuffer[STRING_PADDING] == BEL) {
            shouldShowNewMsgAlert = true;
            currentBuffer[STRING_PADDING] = ' '; // Overwrite the BEL char with a space
        } else if (currentBuffer[STRING_PADDING] == SOH) {
            currentBuffer = currentBuffer + STRING_PADDING; // Skip padding
            currentBuffer = currentBuffer + 1; // Skip SOH char
            extraDataBuffer = currentBuffer;
            char *dleLocation = strchrnul(currentBuffer, DLE);
            *dleLocation = '\0';
            // advance currentBuffer ptr to skip past the extra data
            currentBuffer = dleLocation + 1;
            showInChooserStyle = true;
        } else if (currentBuffer[STRING_PADDING] == STX) {
            PCICR |= bit (PCIE1);   // enable pin change interrupts for A0 to A5
            currentBuffer[STRING_PADDING] = ' '; // Overwrite the STX char with a space
        } else if (currentBuffer[STRING_PADDING] == ETX) {
            PCICR &= ~bit (PCIE1);   // disable pin change interrupts for A0 to A5
            currentBuffer[STRING_PADDING] = ' '; // Overwrite the ETX char with a space
        } else if (currentBuffer[STRING_PADDING] == ENQ) {
            showInInputStyle = ENQ;
            currentBuffer[STRING_PADDING] = ' '; // Overwrite the ENQ char with a space
        } else if (currentBuffer[STRING_PADDING] == EOT) {
            showInInputStyle = EOT;
            currentBuffer[STRING_PADDING] = ' '; // Overwrite the ENQ char with a space
        }
        diagnosticBlink();
    }

//    virtualSerial.print("c: ");
//    virtualSerial.print(currentBuffer);
    stopSerial();

    return shouldShowNewMsgAlert;
}

void setup() {
    strcpy_P(bufferA, ASOT);

    if (DEBUG) {
        bufferA[STRING_PADDING + 10] = 0x00; //chop off intro when debugging
    }

    delay(100); //Try to introduce a bit of a delay to clear out serial noise on boot
    setupDiagnosticLed();
    setupLeds();

    showcountdown();
    showstarfield();

    setupSerial();

    // A0 pin change interrupt
    digitalWrite(A0, HIGH);  // enable pull-up
    PCMSK1 |= bit (PCINT8);  // want pin A0
    PCIFR |= bit (PCIF1);   // clear any outstanding interrupts
    PCICR |= bit (PCIE1);   // enable pin change interrupts for A0 to A5
    // TODO disable based on IMX command

    loopcount = 0;
}

void loop() {

    //showcountdown();
    //showstarfield();
    //showjabber();

//    diagnosticBlink();
    diagnosticLedOn();

    // Returns true if we should show the new msg alert
    if (readSerialData()) {
        showcountdown();
        showstarfield();
    } else {
        //TODO can move the contents of this else block above the readSerialData call to make new messages
        // more responsive
        if (!showInChooserStyle && !showInInputStyle) { //dont advertise when in chooser mode
            showstarfieldcustom(100);
            if (loopcount % ADVERTISE_EVERY == 0) {
                showMsgMeAd();
                showInvaders();
            }
        }
    }
    diagnosticLedOff();
//
////    virtualSerial.print("vsHi");
////    virtualSerial.flush();
//    Serial.println(currentBuffer);
//    Serial.flush();
    if (showInChooserStyle) {
        showAsChooser(currentBuffer, extraDataBuffer);
    } else if (showInInputStyle != NULL) {
        showAsInputStyle(currentBuffer, strlen(currentBuffer) - STRING_PADDING - 1 - 1, showInInputStyle);
    } else {
        // regular marquee
        marquee();
    }

    // TODO: Actually sample the state of the pullup on unused pins and OR it into the mask so we maintain the state.
    // Must do AFTER the cli().
    // TODO: Add offBits also to maintain the pullup state of unused pins.

    loopcount++;
    return;
}



